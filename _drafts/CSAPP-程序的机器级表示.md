---
title: CSAPP-程序的机器级表示
tags:
    -- CSAPP
    -- 读书笔记
---

在使用高级语言如C语言进行编程的时候我们大多数情况下都屏蔽了程序具体的机器级实现。相比之下在使用汇编语言编写程序时程序员必须明确指定程序应该如何管理和使用存储器。这一章主要以intel的IA32指令集为例子讲解C，汇编代码以及目标代码之间的关系。然后会讲到IA32的细节，并且会给出一些使用GDB调试器来检查机器级程序运行时行为的技巧。

<!--more-->

### 1. 历史观点

对于intel的处理器存在下面特征，每个时间上的相继处理器都是向后兼容的-----也就是说较早版本编译的代码可以在较新的处理器上运行。同时intel在IA32的发展过程中加入了许多处理小整数和浮点数向量的格式和指令来提高多媒体应用程序的性能，但是目前的GCC版本都不会使用这些新特性。实际上，在默认启动方式下，GCC会假定代码是一个为i386机器产生的代码，编译器并不会试图使用许多添加到现在看来已经非常古老的体系结构的扩展特性。

### 2. 程序编码

这里首先假设我们通过下面的命令编译我们编写的C代码：
```
gcc -o2 -o p p1.c p2.c
```

这里编译器主要做了下面几件事情：

1. C语言预处理器会扩展源代码，插入所有`#include`指定的内容，并扩展所有的宏指令
2. 编译器将产生的两个源文件汇编
3. 汇编器将汇编代码转换成二进制目标文件`p1.o`和`p2.o`
4. 最后链接器将两个目标文件和库文件的代码（printf）合并，并产生最终的可执行文件。

> 上面编译命令中的`-o2`是指明编译器的优化选项，通常来说，提高优化等级会使得最终程序运行的更快但是编译时间也会更长。

> 使用`-S`可以指定让编译器将C文件编译成汇编代码。如`gcc -O2 -S code.c`；使用`-c`可以指明让编译器编译并汇编c代码。如`gcc -O2 -c code.c`；linux中可以使用反汇编器来将二进制代码转换成汇编代码，如`objdump -d code.o`

### 3. 数据格式

Intel汇编用语中"字（word）"表示16位数据类型。因此32位的数字被称为“双字（double words）“，称64位数位为”四字（quad words）“。下表给出了x86-64机器上的表示：

| C声明 | Intel数据类型 | 汇编代码后缀 | 大小（字节） |
|:-|:-|:-|:-|
| char | 字节 | b | 1 |
| short | 字 | w | 2 |
| int | 双字 | l | 4 |
| long | 四字 | q | 8 |
| char* | 四字 | q | 8 |
| float | 单精度 | s | 4 |
| double | 双精度 | l | 8 |

> C语言数据类型在x86-64的64位机器中指针长度为8个字节。

### 4. 访问信息

对于一个x86-64架构的中央处理器单元来说其中包含了一组16个可以存储64位值的通用寄存器。这些寄存器包括：`%rax`(返回值),`%rbx`(被调用者保存),`%rcx`(第4个参数),`%rdx`(第3个参数),`%rsi`(第2个参数),`%rdi`(第1个参数),`%rbp`(被调用者保存),`%rsp`(栈指针),`%r8`(第5个参数),`%r9`(第5个参数),`%r10`(调用者保存),`%r11`(调用者保存),`%r12`(被调用者保存),`%r13`(被调用者保存),`%r14`(被调用者保存),`%r15`(被调用者保存).

指令可以对这16个寄存器进行不同数据大小的操作，如字节级操作可以访问最低字节，16位操作可以访问最低的2个字节，32位操作可以访问最低的4个字节，尔64位操作可以访问整个寄存器。

对于操作指令来说，如果操作后结果的对象小于8个字节，存在下面两条规则来约束：

1. 生成1字节和2字节数字的指令会保持剩下的字节不变；
2. 生成4字节数字的指令会把高位4个字节置为0.

同时所有的寄存器的低位部分都可以作为字节，字（16位），双字（32位）和四字（64位）来访问，下面以`%rax` 为例说明这一表示：

```
63                            31              15      7       0
+-----------------------------+---------------+-------+-------+
|%rax                         |%eax           |%ax    |%al    | 返回值
+-----------------------------+---------------+-------+-------+
|%rbx                         |%ebx           |%bx    |%bl    | 被调用者保存
+-----------------------------+---------------+-------+-------+
|%rcx                         |%ecx           |%cx    |%cl    | 第4个参数
+-----------------------------+---------------+-------+-------+
|%rdx                         |%edx           |%dx    |%dl   | 第3个参数
+-----------------------------+---------------+-------+-------+
|%rsi                         |%esi           |%si    |%sil   | 第2个参数
+-----------------------------+---------------+-------+-------+
|%rdi                         |%edi           |%di    |%dil   | 第1个参数
+-----------------------------+---------------+-------+-------+
|%rbp                         |%ebp           |%bp    |%bpl   | 被调用者保存
+-----------------------------+---------------+-------+-------+
|%rsp                         |%esp           |%sp    |%spl   | 栈指针
+-----------------------------+---------------+-------+-------+
|%r8                          |%r8d           |%r8w   |%r8b   | 第5个参数
+-----------------------------+---------------+-------+-------+
|%r9                          |%r9d           |%r9w   |%r9b   | 第6个参数
+-----------------------------+---------------+-------+-------+
|%r10                         |%r10d          |%r10w  |%r10b  | 调用者保存
+-----------------------------+---------------+-------+-------+
|%r11                         |%r11d          |%r11w  |%r11b  | 调用者保存
+-----------------------------+---------------+-------+-------+
|%r12                         |%r12d          |%r12w  |%r12b  | 被调用者保存
+-----------------------------+---------------+-------+-------+
|%r13                         |%r13d          |%r13w  |%r13b  | 被调用者保存
+-----------------------------+---------------+-------+-------+
|%r14                         |%r14d          |%r14w  |%r14b  | 被调用者保存
+-----------------------------+---------------+-------+-------+
|%r15                         |%r15d          |%r15w  |%r15b  | 被调用者保存
+-----------------------------+---------------+-------+-------+
```

#### 4.1 操作数指示符

对于大多数指令来说都有一个或者多个操作数，用来指示出执行一个操作中要使用的源数据的值，以及放置操作结果的位置。这里各种不同的操作数的可能性被分为三类：

1. **立即数** 用来表示常数，在汇编语言中的书写方式为`$`后面跟一个标准C表示发的整数，如`$0x1f`
2. **寄存器** 用来表示某个寄存器的内容
3. **内存引用** 根据计算出来的地址（通常为有效地址）访问某个内存位置。这里经常将内存看作是一个很大的数组。

下表中表示了x86-64 系统中常见的操作格式：（这里比例因子`s`必须是1、2、4或者8）

| 类型 | 格式 | 操作数值 | 名称 |
| :- | :- | :- | :- |
| 立即数 | `$Imm` | `Imm` | 立即数寻址 |
| 寄存器 | `r_a` | `R[r_a]` | 寄存器寻址 |
| 存储器 | `Imm` | `M[Imm]` | 绝对寻址 |
| 存储器 | `(r_a)` | `M[R[r_a]]` | 间接寻址 |
| 存储器 | `Imm(r_b)` | `M[Imm + R[r_b]]` | （基址+偏移量）寻址 |
| 存储器 | `(r_b, r_i)` | `M[R[r_b] + R[r_i]]` | 变址寻址 |
| 存储器 | `Imm(r_b, r_i)` | `M[Imm + R[r_b] + R[r_i]]` | 变址寻址 |
| 存储器 | `(,r_i,s)` | `M[R[r_i]*s]` | 比例变址寻址 |
| 存储器 | `Imm(,r_i,s)` | ` M[Imm + R[r_i]*s]` | 比例变址寻址 |
| 存储器 | `(r_b, r_i, s)` | `M[R[r_b]+R[r_i]*s]` | 比例变址寻址 |
| 存储器 | `Imm(r_b, r_i, s)` | `M[Imm+R[r_b]+R[r_i]*s]` | 比例变址寻址 |

#### 4.2 数据传送指令

在编程中最频繁使用的一个操作指令是将数据从一个位置复制到另一个位置。在汇编语言中，将不同的指令划分成指令类，每一类中指令执行相同的操作，只不过操作数大小不同。这里介绍最简单形式的数据传送指令 MOV 类指令，这些指令将数据从源位置复制到目的位置，不做出任何变化。MOV类指令如下表：

| 指令 | 效果 | 描述 |
|:- | :- | :- |
|**MOV S, D** | **D <<-- S** | **传送** |
| movb |  | 传送字节 |
| movw | | 传送字 |
| movl | | 传送双字 |
| movq | | 传送四字 |
| movabsq I, R| R <<-- I | 传送绝对的四字（只能以寄存器作为目的） |

> 在x86-64 中传送指令的两个操作不能都是指向内存地址，所以将一个值从一个内存地址复制到另一个内存地址需要两个操作指令。

这里在强制类型转换或者两个寄存器大小不一致的情况下可能会用到下面零扩展或者符号扩展的操作指令。

| 指令 | 效果 | 描述 |
|:- | :- | :- |
|**MOVZ S, D** | **D <<-- S(零扩展)** | **以零扩展进行传送** |
| movzbw |  | 将做了零扩展的字节传送到字 |
| movzbl | | 将做了零扩展的字节传送到双字 |
| movzwl | | 将做了零扩展的字传送到双字 |
| movzbq | | 将做了零扩展的字节传送到四字 |
| movzwq | | 将做了零扩展的字传送到四字 |

| 指令 | 效果 | 描述 |
|:- | :- | :- |
|**MOVS S, D** | **D <<-- S(符号扩展)** | **传送符号扩展的字节** |
| movsbw |  | 将做了符号扩展的字节传送到字 |
| movsbl | | 将做了符号扩展的字节传送到双字 |
| movswl | | 将做了符号扩展的字传送到双字 |
| movsbq | | 将做了符号扩展的字节传送到四字 |
| movswq | | 将做了符号扩展的字传送到四字 |
| movslq | | 将做了符号扩展的双字传送到四字 |
| cltq | `%rax`<<-- 符号扩展(`%eax`) | 将`%eax`符号扩展到`%rax` |

> 在C语言中所谓的指针就是指的地址。间接引用就是将该指针先放在一个寄存器中，然后在内存引用中使用这个寄存器。C操作符`*`执行指针的间接引用，操作符`&`是取址操作符。


#### 4.3 压入和弹出栈数据

这里要讲的最后两个数据传送操作是讲数据压入程序栈中，以及从程序栈中弹出数据。在 x86-64 中，程序栈存放在内存的某个区域中

| 指令 | 效果 | 描述 |
|:- | :- | :- |
| `pushq S`| `R[%rsp] <-- R[%rsp]-8` `M[R[%rsp]] <-- S` | 将四字压入栈 |
| `popq D` | `D <-- M[R[%rsp]]` `R[%rsp] <-- R[%rsp]+8` | 将四字弹出栈 |

> `%rsp` 的指向总是指向栈顶。

> 在 x86-64 的设计中栈向地址低的方向增长，所以这里当执行压入栈的操作的时候`%rsp`（栈指针）的指会减小。

### 5. 算数和逻辑运算

#### 5.1 加载有效地址

#### 5.2 一元和二元操作

#### 5.3 移位操作


### 6. 控制


### 7. 过程


### 8. 数组的分配和访问


### 9. 异类数据结构




### 10. 算数和逻辑运算


### 11. 算数和逻辑运算


### 12. 算数和逻辑运算


### 13. 算数和逻辑运算


### 14. 算数和逻辑运算



### 15. 算数和逻辑运算